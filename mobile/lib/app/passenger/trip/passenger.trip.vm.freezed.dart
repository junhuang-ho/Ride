// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'passenger.trip.vm.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$PassengerTripStateTearOff {
  const _$PassengerTripStateTearOff();

  _PassengerTripInit init() {
    return const _PassengerTripInit();
  }

  _PassengerTripError error(String? message) {
    return _PassengerTripError(
      message,
    );
  }

  _PassengerTripDriverAddressNotMatched driverAddressNotMatched() {
    return const _PassengerTripDriverAddressNotMatched();
  }

  _PassengerTripStartingTrip startingTrip() {
    return const _PassengerTripStartingTrip();
  }

  _PassengerTripOnTheWay onTheWay(String tixId) {
    return _PassengerTripOnTheWay(
      tixId,
    );
  }

  _PassengerTripEndingTrip endingTrip() {
    return const _PassengerTripEndingTrip();
  }

  _PassengerTripPendingTransaction pendingTransaction() {
    return const _PassengerTripPendingTransaction();
  }

  _PassengerTripEnded ended() {
    return const _PassengerTripEnded();
  }
}

/// @nodoc
const $PassengerTripState = _$PassengerTripStateTearOff();

/// @nodoc
mixin _$PassengerTripState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(String? message) error,
    required TResult Function() driverAddressNotMatched,
    required TResult Function() startingTrip,
    required TResult Function(String tixId) onTheWay,
    required TResult Function() endingTrip,
    required TResult Function() pendingTransaction,
    required TResult Function() ended,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(String? message)? error,
    TResult Function()? driverAddressNotMatched,
    TResult Function()? startingTrip,
    TResult Function(String tixId)? onTheWay,
    TResult Function()? endingTrip,
    TResult Function()? pendingTransaction,
    TResult Function()? ended,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(String? message)? error,
    TResult Function()? driverAddressNotMatched,
    TResult Function()? startingTrip,
    TResult Function(String tixId)? onTheWay,
    TResult Function()? endingTrip,
    TResult Function()? pendingTransaction,
    TResult Function()? ended,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PassengerTripInit value) init,
    required TResult Function(_PassengerTripError value) error,
    required TResult Function(_PassengerTripDriverAddressNotMatched value)
        driverAddressNotMatched,
    required TResult Function(_PassengerTripStartingTrip value) startingTrip,
    required TResult Function(_PassengerTripOnTheWay value) onTheWay,
    required TResult Function(_PassengerTripEndingTrip value) endingTrip,
    required TResult Function(_PassengerTripPendingTransaction value)
        pendingTransaction,
    required TResult Function(_PassengerTripEnded value) ended,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_PassengerTripInit value)? init,
    TResult Function(_PassengerTripError value)? error,
    TResult Function(_PassengerTripDriverAddressNotMatched value)?
        driverAddressNotMatched,
    TResult Function(_PassengerTripStartingTrip value)? startingTrip,
    TResult Function(_PassengerTripOnTheWay value)? onTheWay,
    TResult Function(_PassengerTripEndingTrip value)? endingTrip,
    TResult Function(_PassengerTripPendingTransaction value)?
        pendingTransaction,
    TResult Function(_PassengerTripEnded value)? ended,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PassengerTripInit value)? init,
    TResult Function(_PassengerTripError value)? error,
    TResult Function(_PassengerTripDriverAddressNotMatched value)?
        driverAddressNotMatched,
    TResult Function(_PassengerTripStartingTrip value)? startingTrip,
    TResult Function(_PassengerTripOnTheWay value)? onTheWay,
    TResult Function(_PassengerTripEndingTrip value)? endingTrip,
    TResult Function(_PassengerTripPendingTransaction value)?
        pendingTransaction,
    TResult Function(_PassengerTripEnded value)? ended,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PassengerTripStateCopyWith<$Res> {
  factory $PassengerTripStateCopyWith(
          PassengerTripState value, $Res Function(PassengerTripState) then) =
      _$PassengerTripStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$PassengerTripStateCopyWithImpl<$Res>
    implements $PassengerTripStateCopyWith<$Res> {
  _$PassengerTripStateCopyWithImpl(this._value, this._then);

  final PassengerTripState _value;
  // ignore: unused_field
  final $Res Function(PassengerTripState) _then;
}

/// @nodoc
abstract class _$PassengerTripInitCopyWith<$Res> {
  factory _$PassengerTripInitCopyWith(
          _PassengerTripInit value, $Res Function(_PassengerTripInit) then) =
      __$PassengerTripInitCopyWithImpl<$Res>;
}

/// @nodoc
class __$PassengerTripInitCopyWithImpl<$Res>
    extends _$PassengerTripStateCopyWithImpl<$Res>
    implements _$PassengerTripInitCopyWith<$Res> {
  __$PassengerTripInitCopyWithImpl(
      _PassengerTripInit _value, $Res Function(_PassengerTripInit) _then)
      : super(_value, (v) => _then(v as _PassengerTripInit));

  @override
  _PassengerTripInit get _value => super._value as _PassengerTripInit;
}

/// @nodoc

class _$_PassengerTripInit implements _PassengerTripInit {
  const _$_PassengerTripInit();

  @override
  String toString() {
    return 'PassengerTripState.init()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _PassengerTripInit);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(String? message) error,
    required TResult Function() driverAddressNotMatched,
    required TResult Function() startingTrip,
    required TResult Function(String tixId) onTheWay,
    required TResult Function() endingTrip,
    required TResult Function() pendingTransaction,
    required TResult Function() ended,
  }) {
    return init();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(String? message)? error,
    TResult Function()? driverAddressNotMatched,
    TResult Function()? startingTrip,
    TResult Function(String tixId)? onTheWay,
    TResult Function()? endingTrip,
    TResult Function()? pendingTransaction,
    TResult Function()? ended,
  }) {
    return init?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(String? message)? error,
    TResult Function()? driverAddressNotMatched,
    TResult Function()? startingTrip,
    TResult Function(String tixId)? onTheWay,
    TResult Function()? endingTrip,
    TResult Function()? pendingTransaction,
    TResult Function()? ended,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PassengerTripInit value) init,
    required TResult Function(_PassengerTripError value) error,
    required TResult Function(_PassengerTripDriverAddressNotMatched value)
        driverAddressNotMatched,
    required TResult Function(_PassengerTripStartingTrip value) startingTrip,
    required TResult Function(_PassengerTripOnTheWay value) onTheWay,
    required TResult Function(_PassengerTripEndingTrip value) endingTrip,
    required TResult Function(_PassengerTripPendingTransaction value)
        pendingTransaction,
    required TResult Function(_PassengerTripEnded value) ended,
  }) {
    return init(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_PassengerTripInit value)? init,
    TResult Function(_PassengerTripError value)? error,
    TResult Function(_PassengerTripDriverAddressNotMatched value)?
        driverAddressNotMatched,
    TResult Function(_PassengerTripStartingTrip value)? startingTrip,
    TResult Function(_PassengerTripOnTheWay value)? onTheWay,
    TResult Function(_PassengerTripEndingTrip value)? endingTrip,
    TResult Function(_PassengerTripPendingTransaction value)?
        pendingTransaction,
    TResult Function(_PassengerTripEnded value)? ended,
  }) {
    return init?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PassengerTripInit value)? init,
    TResult Function(_PassengerTripError value)? error,
    TResult Function(_PassengerTripDriverAddressNotMatched value)?
        driverAddressNotMatched,
    TResult Function(_PassengerTripStartingTrip value)? startingTrip,
    TResult Function(_PassengerTripOnTheWay value)? onTheWay,
    TResult Function(_PassengerTripEndingTrip value)? endingTrip,
    TResult Function(_PassengerTripPendingTransaction value)?
        pendingTransaction,
    TResult Function(_PassengerTripEnded value)? ended,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init(this);
    }
    return orElse();
  }
}

abstract class _PassengerTripInit implements PassengerTripState {
  const factory _PassengerTripInit() = _$_PassengerTripInit;
}

/// @nodoc
abstract class _$PassengerTripErrorCopyWith<$Res> {
  factory _$PassengerTripErrorCopyWith(
          _PassengerTripError value, $Res Function(_PassengerTripError) then) =
      __$PassengerTripErrorCopyWithImpl<$Res>;
  $Res call({String? message});
}

/// @nodoc
class __$PassengerTripErrorCopyWithImpl<$Res>
    extends _$PassengerTripStateCopyWithImpl<$Res>
    implements _$PassengerTripErrorCopyWith<$Res> {
  __$PassengerTripErrorCopyWithImpl(
      _PassengerTripError _value, $Res Function(_PassengerTripError) _then)
      : super(_value, (v) => _then(v as _PassengerTripError));

  @override
  _PassengerTripError get _value => super._value as _PassengerTripError;

  @override
  $Res call({
    Object? message = freezed,
  }) {
    return _then(_PassengerTripError(
      message == freezed
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$_PassengerTripError implements _PassengerTripError {
  const _$_PassengerTripError(this.message);

  @override
  final String? message;

  @override
  String toString() {
    return 'PassengerTripState.error(message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PassengerTripError &&
            const DeepCollectionEquality().equals(other.message, message));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(message));

  @JsonKey(ignore: true)
  @override
  _$PassengerTripErrorCopyWith<_PassengerTripError> get copyWith =>
      __$PassengerTripErrorCopyWithImpl<_PassengerTripError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(String? message) error,
    required TResult Function() driverAddressNotMatched,
    required TResult Function() startingTrip,
    required TResult Function(String tixId) onTheWay,
    required TResult Function() endingTrip,
    required TResult Function() pendingTransaction,
    required TResult Function() ended,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(String? message)? error,
    TResult Function()? driverAddressNotMatched,
    TResult Function()? startingTrip,
    TResult Function(String tixId)? onTheWay,
    TResult Function()? endingTrip,
    TResult Function()? pendingTransaction,
    TResult Function()? ended,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(String? message)? error,
    TResult Function()? driverAddressNotMatched,
    TResult Function()? startingTrip,
    TResult Function(String tixId)? onTheWay,
    TResult Function()? endingTrip,
    TResult Function()? pendingTransaction,
    TResult Function()? ended,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PassengerTripInit value) init,
    required TResult Function(_PassengerTripError value) error,
    required TResult Function(_PassengerTripDriverAddressNotMatched value)
        driverAddressNotMatched,
    required TResult Function(_PassengerTripStartingTrip value) startingTrip,
    required TResult Function(_PassengerTripOnTheWay value) onTheWay,
    required TResult Function(_PassengerTripEndingTrip value) endingTrip,
    required TResult Function(_PassengerTripPendingTransaction value)
        pendingTransaction,
    required TResult Function(_PassengerTripEnded value) ended,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_PassengerTripInit value)? init,
    TResult Function(_PassengerTripError value)? error,
    TResult Function(_PassengerTripDriverAddressNotMatched value)?
        driverAddressNotMatched,
    TResult Function(_PassengerTripStartingTrip value)? startingTrip,
    TResult Function(_PassengerTripOnTheWay value)? onTheWay,
    TResult Function(_PassengerTripEndingTrip value)? endingTrip,
    TResult Function(_PassengerTripPendingTransaction value)?
        pendingTransaction,
    TResult Function(_PassengerTripEnded value)? ended,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PassengerTripInit value)? init,
    TResult Function(_PassengerTripError value)? error,
    TResult Function(_PassengerTripDriverAddressNotMatched value)?
        driverAddressNotMatched,
    TResult Function(_PassengerTripStartingTrip value)? startingTrip,
    TResult Function(_PassengerTripOnTheWay value)? onTheWay,
    TResult Function(_PassengerTripEndingTrip value)? endingTrip,
    TResult Function(_PassengerTripPendingTransaction value)?
        pendingTransaction,
    TResult Function(_PassengerTripEnded value)? ended,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _PassengerTripError implements PassengerTripState {
  const factory _PassengerTripError(String? message) = _$_PassengerTripError;

  String? get message;
  @JsonKey(ignore: true)
  _$PassengerTripErrorCopyWith<_PassengerTripError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$PassengerTripDriverAddressNotMatchedCopyWith<$Res> {
  factory _$PassengerTripDriverAddressNotMatchedCopyWith(
          _PassengerTripDriverAddressNotMatched value,
          $Res Function(_PassengerTripDriverAddressNotMatched) then) =
      __$PassengerTripDriverAddressNotMatchedCopyWithImpl<$Res>;
}

/// @nodoc
class __$PassengerTripDriverAddressNotMatchedCopyWithImpl<$Res>
    extends _$PassengerTripStateCopyWithImpl<$Res>
    implements _$PassengerTripDriverAddressNotMatchedCopyWith<$Res> {
  __$PassengerTripDriverAddressNotMatchedCopyWithImpl(
      _PassengerTripDriverAddressNotMatched _value,
      $Res Function(_PassengerTripDriverAddressNotMatched) _then)
      : super(_value, (v) => _then(v as _PassengerTripDriverAddressNotMatched));

  @override
  _PassengerTripDriverAddressNotMatched get _value =>
      super._value as _PassengerTripDriverAddressNotMatched;
}

/// @nodoc

class _$_PassengerTripDriverAddressNotMatched
    implements _PassengerTripDriverAddressNotMatched {
  const _$_PassengerTripDriverAddressNotMatched();

  @override
  String toString() {
    return 'PassengerTripState.driverAddressNotMatched()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PassengerTripDriverAddressNotMatched);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(String? message) error,
    required TResult Function() driverAddressNotMatched,
    required TResult Function() startingTrip,
    required TResult Function(String tixId) onTheWay,
    required TResult Function() endingTrip,
    required TResult Function() pendingTransaction,
    required TResult Function() ended,
  }) {
    return driverAddressNotMatched();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(String? message)? error,
    TResult Function()? driverAddressNotMatched,
    TResult Function()? startingTrip,
    TResult Function(String tixId)? onTheWay,
    TResult Function()? endingTrip,
    TResult Function()? pendingTransaction,
    TResult Function()? ended,
  }) {
    return driverAddressNotMatched?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(String? message)? error,
    TResult Function()? driverAddressNotMatched,
    TResult Function()? startingTrip,
    TResult Function(String tixId)? onTheWay,
    TResult Function()? endingTrip,
    TResult Function()? pendingTransaction,
    TResult Function()? ended,
    required TResult orElse(),
  }) {
    if (driverAddressNotMatched != null) {
      return driverAddressNotMatched();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PassengerTripInit value) init,
    required TResult Function(_PassengerTripError value) error,
    required TResult Function(_PassengerTripDriverAddressNotMatched value)
        driverAddressNotMatched,
    required TResult Function(_PassengerTripStartingTrip value) startingTrip,
    required TResult Function(_PassengerTripOnTheWay value) onTheWay,
    required TResult Function(_PassengerTripEndingTrip value) endingTrip,
    required TResult Function(_PassengerTripPendingTransaction value)
        pendingTransaction,
    required TResult Function(_PassengerTripEnded value) ended,
  }) {
    return driverAddressNotMatched(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_PassengerTripInit value)? init,
    TResult Function(_PassengerTripError value)? error,
    TResult Function(_PassengerTripDriverAddressNotMatched value)?
        driverAddressNotMatched,
    TResult Function(_PassengerTripStartingTrip value)? startingTrip,
    TResult Function(_PassengerTripOnTheWay value)? onTheWay,
    TResult Function(_PassengerTripEndingTrip value)? endingTrip,
    TResult Function(_PassengerTripPendingTransaction value)?
        pendingTransaction,
    TResult Function(_PassengerTripEnded value)? ended,
  }) {
    return driverAddressNotMatched?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PassengerTripInit value)? init,
    TResult Function(_PassengerTripError value)? error,
    TResult Function(_PassengerTripDriverAddressNotMatched value)?
        driverAddressNotMatched,
    TResult Function(_PassengerTripStartingTrip value)? startingTrip,
    TResult Function(_PassengerTripOnTheWay value)? onTheWay,
    TResult Function(_PassengerTripEndingTrip value)? endingTrip,
    TResult Function(_PassengerTripPendingTransaction value)?
        pendingTransaction,
    TResult Function(_PassengerTripEnded value)? ended,
    required TResult orElse(),
  }) {
    if (driverAddressNotMatched != null) {
      return driverAddressNotMatched(this);
    }
    return orElse();
  }
}

abstract class _PassengerTripDriverAddressNotMatched
    implements PassengerTripState {
  const factory _PassengerTripDriverAddressNotMatched() =
      _$_PassengerTripDriverAddressNotMatched;
}

/// @nodoc
abstract class _$PassengerTripStartingTripCopyWith<$Res> {
  factory _$PassengerTripStartingTripCopyWith(_PassengerTripStartingTrip value,
          $Res Function(_PassengerTripStartingTrip) then) =
      __$PassengerTripStartingTripCopyWithImpl<$Res>;
}

/// @nodoc
class __$PassengerTripStartingTripCopyWithImpl<$Res>
    extends _$PassengerTripStateCopyWithImpl<$Res>
    implements _$PassengerTripStartingTripCopyWith<$Res> {
  __$PassengerTripStartingTripCopyWithImpl(_PassengerTripStartingTrip _value,
      $Res Function(_PassengerTripStartingTrip) _then)
      : super(_value, (v) => _then(v as _PassengerTripStartingTrip));

  @override
  _PassengerTripStartingTrip get _value =>
      super._value as _PassengerTripStartingTrip;
}

/// @nodoc

class _$_PassengerTripStartingTrip implements _PassengerTripStartingTrip {
  const _$_PassengerTripStartingTrip();

  @override
  String toString() {
    return 'PassengerTripState.startingTrip()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PassengerTripStartingTrip);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(String? message) error,
    required TResult Function() driverAddressNotMatched,
    required TResult Function() startingTrip,
    required TResult Function(String tixId) onTheWay,
    required TResult Function() endingTrip,
    required TResult Function() pendingTransaction,
    required TResult Function() ended,
  }) {
    return startingTrip();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(String? message)? error,
    TResult Function()? driverAddressNotMatched,
    TResult Function()? startingTrip,
    TResult Function(String tixId)? onTheWay,
    TResult Function()? endingTrip,
    TResult Function()? pendingTransaction,
    TResult Function()? ended,
  }) {
    return startingTrip?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(String? message)? error,
    TResult Function()? driverAddressNotMatched,
    TResult Function()? startingTrip,
    TResult Function(String tixId)? onTheWay,
    TResult Function()? endingTrip,
    TResult Function()? pendingTransaction,
    TResult Function()? ended,
    required TResult orElse(),
  }) {
    if (startingTrip != null) {
      return startingTrip();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PassengerTripInit value) init,
    required TResult Function(_PassengerTripError value) error,
    required TResult Function(_PassengerTripDriverAddressNotMatched value)
        driverAddressNotMatched,
    required TResult Function(_PassengerTripStartingTrip value) startingTrip,
    required TResult Function(_PassengerTripOnTheWay value) onTheWay,
    required TResult Function(_PassengerTripEndingTrip value) endingTrip,
    required TResult Function(_PassengerTripPendingTransaction value)
        pendingTransaction,
    required TResult Function(_PassengerTripEnded value) ended,
  }) {
    return startingTrip(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_PassengerTripInit value)? init,
    TResult Function(_PassengerTripError value)? error,
    TResult Function(_PassengerTripDriverAddressNotMatched value)?
        driverAddressNotMatched,
    TResult Function(_PassengerTripStartingTrip value)? startingTrip,
    TResult Function(_PassengerTripOnTheWay value)? onTheWay,
    TResult Function(_PassengerTripEndingTrip value)? endingTrip,
    TResult Function(_PassengerTripPendingTransaction value)?
        pendingTransaction,
    TResult Function(_PassengerTripEnded value)? ended,
  }) {
    return startingTrip?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PassengerTripInit value)? init,
    TResult Function(_PassengerTripError value)? error,
    TResult Function(_PassengerTripDriverAddressNotMatched value)?
        driverAddressNotMatched,
    TResult Function(_PassengerTripStartingTrip value)? startingTrip,
    TResult Function(_PassengerTripOnTheWay value)? onTheWay,
    TResult Function(_PassengerTripEndingTrip value)? endingTrip,
    TResult Function(_PassengerTripPendingTransaction value)?
        pendingTransaction,
    TResult Function(_PassengerTripEnded value)? ended,
    required TResult orElse(),
  }) {
    if (startingTrip != null) {
      return startingTrip(this);
    }
    return orElse();
  }
}

abstract class _PassengerTripStartingTrip implements PassengerTripState {
  const factory _PassengerTripStartingTrip() = _$_PassengerTripStartingTrip;
}

/// @nodoc
abstract class _$PassengerTripOnTheWayCopyWith<$Res> {
  factory _$PassengerTripOnTheWayCopyWith(_PassengerTripOnTheWay value,
          $Res Function(_PassengerTripOnTheWay) then) =
      __$PassengerTripOnTheWayCopyWithImpl<$Res>;
  $Res call({String tixId});
}

/// @nodoc
class __$PassengerTripOnTheWayCopyWithImpl<$Res>
    extends _$PassengerTripStateCopyWithImpl<$Res>
    implements _$PassengerTripOnTheWayCopyWith<$Res> {
  __$PassengerTripOnTheWayCopyWithImpl(_PassengerTripOnTheWay _value,
      $Res Function(_PassengerTripOnTheWay) _then)
      : super(_value, (v) => _then(v as _PassengerTripOnTheWay));

  @override
  _PassengerTripOnTheWay get _value => super._value as _PassengerTripOnTheWay;

  @override
  $Res call({
    Object? tixId = freezed,
  }) {
    return _then(_PassengerTripOnTheWay(
      tixId == freezed
          ? _value.tixId
          : tixId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_PassengerTripOnTheWay implements _PassengerTripOnTheWay {
  const _$_PassengerTripOnTheWay(this.tixId);

  @override
  final String tixId;

  @override
  String toString() {
    return 'PassengerTripState.onTheWay(tixId: $tixId)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PassengerTripOnTheWay &&
            const DeepCollectionEquality().equals(other.tixId, tixId));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(tixId));

  @JsonKey(ignore: true)
  @override
  _$PassengerTripOnTheWayCopyWith<_PassengerTripOnTheWay> get copyWith =>
      __$PassengerTripOnTheWayCopyWithImpl<_PassengerTripOnTheWay>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(String? message) error,
    required TResult Function() driverAddressNotMatched,
    required TResult Function() startingTrip,
    required TResult Function(String tixId) onTheWay,
    required TResult Function() endingTrip,
    required TResult Function() pendingTransaction,
    required TResult Function() ended,
  }) {
    return onTheWay(tixId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(String? message)? error,
    TResult Function()? driverAddressNotMatched,
    TResult Function()? startingTrip,
    TResult Function(String tixId)? onTheWay,
    TResult Function()? endingTrip,
    TResult Function()? pendingTransaction,
    TResult Function()? ended,
  }) {
    return onTheWay?.call(tixId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(String? message)? error,
    TResult Function()? driverAddressNotMatched,
    TResult Function()? startingTrip,
    TResult Function(String tixId)? onTheWay,
    TResult Function()? endingTrip,
    TResult Function()? pendingTransaction,
    TResult Function()? ended,
    required TResult orElse(),
  }) {
    if (onTheWay != null) {
      return onTheWay(tixId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PassengerTripInit value) init,
    required TResult Function(_PassengerTripError value) error,
    required TResult Function(_PassengerTripDriverAddressNotMatched value)
        driverAddressNotMatched,
    required TResult Function(_PassengerTripStartingTrip value) startingTrip,
    required TResult Function(_PassengerTripOnTheWay value) onTheWay,
    required TResult Function(_PassengerTripEndingTrip value) endingTrip,
    required TResult Function(_PassengerTripPendingTransaction value)
        pendingTransaction,
    required TResult Function(_PassengerTripEnded value) ended,
  }) {
    return onTheWay(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_PassengerTripInit value)? init,
    TResult Function(_PassengerTripError value)? error,
    TResult Function(_PassengerTripDriverAddressNotMatched value)?
        driverAddressNotMatched,
    TResult Function(_PassengerTripStartingTrip value)? startingTrip,
    TResult Function(_PassengerTripOnTheWay value)? onTheWay,
    TResult Function(_PassengerTripEndingTrip value)? endingTrip,
    TResult Function(_PassengerTripPendingTransaction value)?
        pendingTransaction,
    TResult Function(_PassengerTripEnded value)? ended,
  }) {
    return onTheWay?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PassengerTripInit value)? init,
    TResult Function(_PassengerTripError value)? error,
    TResult Function(_PassengerTripDriverAddressNotMatched value)?
        driverAddressNotMatched,
    TResult Function(_PassengerTripStartingTrip value)? startingTrip,
    TResult Function(_PassengerTripOnTheWay value)? onTheWay,
    TResult Function(_PassengerTripEndingTrip value)? endingTrip,
    TResult Function(_PassengerTripPendingTransaction value)?
        pendingTransaction,
    TResult Function(_PassengerTripEnded value)? ended,
    required TResult orElse(),
  }) {
    if (onTheWay != null) {
      return onTheWay(this);
    }
    return orElse();
  }
}

abstract class _PassengerTripOnTheWay implements PassengerTripState {
  const factory _PassengerTripOnTheWay(String tixId) = _$_PassengerTripOnTheWay;

  String get tixId;
  @JsonKey(ignore: true)
  _$PassengerTripOnTheWayCopyWith<_PassengerTripOnTheWay> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$PassengerTripEndingTripCopyWith<$Res> {
  factory _$PassengerTripEndingTripCopyWith(_PassengerTripEndingTrip value,
          $Res Function(_PassengerTripEndingTrip) then) =
      __$PassengerTripEndingTripCopyWithImpl<$Res>;
}

/// @nodoc
class __$PassengerTripEndingTripCopyWithImpl<$Res>
    extends _$PassengerTripStateCopyWithImpl<$Res>
    implements _$PassengerTripEndingTripCopyWith<$Res> {
  __$PassengerTripEndingTripCopyWithImpl(_PassengerTripEndingTrip _value,
      $Res Function(_PassengerTripEndingTrip) _then)
      : super(_value, (v) => _then(v as _PassengerTripEndingTrip));

  @override
  _PassengerTripEndingTrip get _value =>
      super._value as _PassengerTripEndingTrip;
}

/// @nodoc

class _$_PassengerTripEndingTrip implements _PassengerTripEndingTrip {
  const _$_PassengerTripEndingTrip();

  @override
  String toString() {
    return 'PassengerTripState.endingTrip()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _PassengerTripEndingTrip);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(String? message) error,
    required TResult Function() driverAddressNotMatched,
    required TResult Function() startingTrip,
    required TResult Function(String tixId) onTheWay,
    required TResult Function() endingTrip,
    required TResult Function() pendingTransaction,
    required TResult Function() ended,
  }) {
    return endingTrip();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(String? message)? error,
    TResult Function()? driverAddressNotMatched,
    TResult Function()? startingTrip,
    TResult Function(String tixId)? onTheWay,
    TResult Function()? endingTrip,
    TResult Function()? pendingTransaction,
    TResult Function()? ended,
  }) {
    return endingTrip?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(String? message)? error,
    TResult Function()? driverAddressNotMatched,
    TResult Function()? startingTrip,
    TResult Function(String tixId)? onTheWay,
    TResult Function()? endingTrip,
    TResult Function()? pendingTransaction,
    TResult Function()? ended,
    required TResult orElse(),
  }) {
    if (endingTrip != null) {
      return endingTrip();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PassengerTripInit value) init,
    required TResult Function(_PassengerTripError value) error,
    required TResult Function(_PassengerTripDriverAddressNotMatched value)
        driverAddressNotMatched,
    required TResult Function(_PassengerTripStartingTrip value) startingTrip,
    required TResult Function(_PassengerTripOnTheWay value) onTheWay,
    required TResult Function(_PassengerTripEndingTrip value) endingTrip,
    required TResult Function(_PassengerTripPendingTransaction value)
        pendingTransaction,
    required TResult Function(_PassengerTripEnded value) ended,
  }) {
    return endingTrip(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_PassengerTripInit value)? init,
    TResult Function(_PassengerTripError value)? error,
    TResult Function(_PassengerTripDriverAddressNotMatched value)?
        driverAddressNotMatched,
    TResult Function(_PassengerTripStartingTrip value)? startingTrip,
    TResult Function(_PassengerTripOnTheWay value)? onTheWay,
    TResult Function(_PassengerTripEndingTrip value)? endingTrip,
    TResult Function(_PassengerTripPendingTransaction value)?
        pendingTransaction,
    TResult Function(_PassengerTripEnded value)? ended,
  }) {
    return endingTrip?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PassengerTripInit value)? init,
    TResult Function(_PassengerTripError value)? error,
    TResult Function(_PassengerTripDriverAddressNotMatched value)?
        driverAddressNotMatched,
    TResult Function(_PassengerTripStartingTrip value)? startingTrip,
    TResult Function(_PassengerTripOnTheWay value)? onTheWay,
    TResult Function(_PassengerTripEndingTrip value)? endingTrip,
    TResult Function(_PassengerTripPendingTransaction value)?
        pendingTransaction,
    TResult Function(_PassengerTripEnded value)? ended,
    required TResult orElse(),
  }) {
    if (endingTrip != null) {
      return endingTrip(this);
    }
    return orElse();
  }
}

abstract class _PassengerTripEndingTrip implements PassengerTripState {
  const factory _PassengerTripEndingTrip() = _$_PassengerTripEndingTrip;
}

/// @nodoc
abstract class _$PassengerTripPendingTransactionCopyWith<$Res> {
  factory _$PassengerTripPendingTransactionCopyWith(
          _PassengerTripPendingTransaction value,
          $Res Function(_PassengerTripPendingTransaction) then) =
      __$PassengerTripPendingTransactionCopyWithImpl<$Res>;
}

/// @nodoc
class __$PassengerTripPendingTransactionCopyWithImpl<$Res>
    extends _$PassengerTripStateCopyWithImpl<$Res>
    implements _$PassengerTripPendingTransactionCopyWith<$Res> {
  __$PassengerTripPendingTransactionCopyWithImpl(
      _PassengerTripPendingTransaction _value,
      $Res Function(_PassengerTripPendingTransaction) _then)
      : super(_value, (v) => _then(v as _PassengerTripPendingTransaction));

  @override
  _PassengerTripPendingTransaction get _value =>
      super._value as _PassengerTripPendingTransaction;
}

/// @nodoc

class _$_PassengerTripPendingTransaction
    implements _PassengerTripPendingTransaction {
  const _$_PassengerTripPendingTransaction();

  @override
  String toString() {
    return 'PassengerTripState.pendingTransaction()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PassengerTripPendingTransaction);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(String? message) error,
    required TResult Function() driverAddressNotMatched,
    required TResult Function() startingTrip,
    required TResult Function(String tixId) onTheWay,
    required TResult Function() endingTrip,
    required TResult Function() pendingTransaction,
    required TResult Function() ended,
  }) {
    return pendingTransaction();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(String? message)? error,
    TResult Function()? driverAddressNotMatched,
    TResult Function()? startingTrip,
    TResult Function(String tixId)? onTheWay,
    TResult Function()? endingTrip,
    TResult Function()? pendingTransaction,
    TResult Function()? ended,
  }) {
    return pendingTransaction?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(String? message)? error,
    TResult Function()? driverAddressNotMatched,
    TResult Function()? startingTrip,
    TResult Function(String tixId)? onTheWay,
    TResult Function()? endingTrip,
    TResult Function()? pendingTransaction,
    TResult Function()? ended,
    required TResult orElse(),
  }) {
    if (pendingTransaction != null) {
      return pendingTransaction();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PassengerTripInit value) init,
    required TResult Function(_PassengerTripError value) error,
    required TResult Function(_PassengerTripDriverAddressNotMatched value)
        driverAddressNotMatched,
    required TResult Function(_PassengerTripStartingTrip value) startingTrip,
    required TResult Function(_PassengerTripOnTheWay value) onTheWay,
    required TResult Function(_PassengerTripEndingTrip value) endingTrip,
    required TResult Function(_PassengerTripPendingTransaction value)
        pendingTransaction,
    required TResult Function(_PassengerTripEnded value) ended,
  }) {
    return pendingTransaction(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_PassengerTripInit value)? init,
    TResult Function(_PassengerTripError value)? error,
    TResult Function(_PassengerTripDriverAddressNotMatched value)?
        driverAddressNotMatched,
    TResult Function(_PassengerTripStartingTrip value)? startingTrip,
    TResult Function(_PassengerTripOnTheWay value)? onTheWay,
    TResult Function(_PassengerTripEndingTrip value)? endingTrip,
    TResult Function(_PassengerTripPendingTransaction value)?
        pendingTransaction,
    TResult Function(_PassengerTripEnded value)? ended,
  }) {
    return pendingTransaction?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PassengerTripInit value)? init,
    TResult Function(_PassengerTripError value)? error,
    TResult Function(_PassengerTripDriverAddressNotMatched value)?
        driverAddressNotMatched,
    TResult Function(_PassengerTripStartingTrip value)? startingTrip,
    TResult Function(_PassengerTripOnTheWay value)? onTheWay,
    TResult Function(_PassengerTripEndingTrip value)? endingTrip,
    TResult Function(_PassengerTripPendingTransaction value)?
        pendingTransaction,
    TResult Function(_PassengerTripEnded value)? ended,
    required TResult orElse(),
  }) {
    if (pendingTransaction != null) {
      return pendingTransaction(this);
    }
    return orElse();
  }
}

abstract class _PassengerTripPendingTransaction implements PassengerTripState {
  const factory _PassengerTripPendingTransaction() =
      _$_PassengerTripPendingTransaction;
}

/// @nodoc
abstract class _$PassengerTripEndedCopyWith<$Res> {
  factory _$PassengerTripEndedCopyWith(
          _PassengerTripEnded value, $Res Function(_PassengerTripEnded) then) =
      __$PassengerTripEndedCopyWithImpl<$Res>;
}

/// @nodoc
class __$PassengerTripEndedCopyWithImpl<$Res>
    extends _$PassengerTripStateCopyWithImpl<$Res>
    implements _$PassengerTripEndedCopyWith<$Res> {
  __$PassengerTripEndedCopyWithImpl(
      _PassengerTripEnded _value, $Res Function(_PassengerTripEnded) _then)
      : super(_value, (v) => _then(v as _PassengerTripEnded));

  @override
  _PassengerTripEnded get _value => super._value as _PassengerTripEnded;
}

/// @nodoc

class _$_PassengerTripEnded implements _PassengerTripEnded {
  const _$_PassengerTripEnded();

  @override
  String toString() {
    return 'PassengerTripState.ended()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _PassengerTripEnded);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(String? message) error,
    required TResult Function() driverAddressNotMatched,
    required TResult Function() startingTrip,
    required TResult Function(String tixId) onTheWay,
    required TResult Function() endingTrip,
    required TResult Function() pendingTransaction,
    required TResult Function() ended,
  }) {
    return ended();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(String? message)? error,
    TResult Function()? driverAddressNotMatched,
    TResult Function()? startingTrip,
    TResult Function(String tixId)? onTheWay,
    TResult Function()? endingTrip,
    TResult Function()? pendingTransaction,
    TResult Function()? ended,
  }) {
    return ended?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(String? message)? error,
    TResult Function()? driverAddressNotMatched,
    TResult Function()? startingTrip,
    TResult Function(String tixId)? onTheWay,
    TResult Function()? endingTrip,
    TResult Function()? pendingTransaction,
    TResult Function()? ended,
    required TResult orElse(),
  }) {
    if (ended != null) {
      return ended();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PassengerTripInit value) init,
    required TResult Function(_PassengerTripError value) error,
    required TResult Function(_PassengerTripDriverAddressNotMatched value)
        driverAddressNotMatched,
    required TResult Function(_PassengerTripStartingTrip value) startingTrip,
    required TResult Function(_PassengerTripOnTheWay value) onTheWay,
    required TResult Function(_PassengerTripEndingTrip value) endingTrip,
    required TResult Function(_PassengerTripPendingTransaction value)
        pendingTransaction,
    required TResult Function(_PassengerTripEnded value) ended,
  }) {
    return ended(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_PassengerTripInit value)? init,
    TResult Function(_PassengerTripError value)? error,
    TResult Function(_PassengerTripDriverAddressNotMatched value)?
        driverAddressNotMatched,
    TResult Function(_PassengerTripStartingTrip value)? startingTrip,
    TResult Function(_PassengerTripOnTheWay value)? onTheWay,
    TResult Function(_PassengerTripEndingTrip value)? endingTrip,
    TResult Function(_PassengerTripPendingTransaction value)?
        pendingTransaction,
    TResult Function(_PassengerTripEnded value)? ended,
  }) {
    return ended?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PassengerTripInit value)? init,
    TResult Function(_PassengerTripError value)? error,
    TResult Function(_PassengerTripDriverAddressNotMatched value)?
        driverAddressNotMatched,
    TResult Function(_PassengerTripStartingTrip value)? startingTrip,
    TResult Function(_PassengerTripOnTheWay value)? onTheWay,
    TResult Function(_PassengerTripEndingTrip value)? endingTrip,
    TResult Function(_PassengerTripPendingTransaction value)?
        pendingTransaction,
    TResult Function(_PassengerTripEnded value)? ended,
    required TResult orElse(),
  }) {
    if (ended != null) {
      return ended(this);
    }
    return orElse();
  }
}

abstract class _PassengerTripEnded implements PassengerTripState {
  const factory _PassengerTripEnded() = _$_PassengerTripEnded;
}
